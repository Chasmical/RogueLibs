"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"documentationSidebar":[{"type":"link","label":"Introduction","href":"/RogueLibs/docs/intro","docId":"intro"},{"type":"category","label":"User\'s Guide","items":[{"type":"link","label":"Installation","href":"/RogueLibs/docs/user/installation","docId":"user/installation"},{"type":"link","label":"Frequently Encountered Problems","href":"/RogueLibs/docs/user/troubleshooting","docId":"user/troubleshooting"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Developer\'s Guide","items":[{"type":"link","label":"Getting Started","href":"/RogueLibs/docs/dev/getting-started","docId":"dev/getting-started"},{"type":"category","label":"Custom Items and Abilities","items":[{"type":"link","label":"Creating a Custom Item","href":"/RogueLibs/docs/dev/items/create-item","docId":"dev/items/create-item"},{"type":"category","label":"Adding Functionality","items":[{"type":"link","label":"Usable Items","href":"/RogueLibs/docs/dev/items/usable-items","docId":"dev/items/usable-items"},{"type":"link","label":"Combinable Items","href":"/RogueLibs/docs/dev/items/combinable-items","docId":"dev/items/combinable-items"},{"type":"link","label":"Targetable Items","href":"/RogueLibs/docs/dev/items/targetable-items","docId":"dev/items/targetable-items"},{"type":"link","label":"Targetable Items +","href":"/RogueLibs/docs/dev/items/targetable-items-plus","docId":"dev/items/targetable-items-plus"},{"type":"link","label":"Recharging Items","href":"/RogueLibs/docs/dev/items/recharging-items","docId":"dev/items/recharging-items"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Weapons","items":[{"type":"link","label":"Melee Weapons*","href":"/RogueLibs/docs/dev/items/weapons/melee-weapons","docId":"dev/items/weapons/melee-weapons"},{"type":"link","label":"Thrown Weapons*","href":"/RogueLibs/docs/dev/items/weapons/thrown-weapons","docId":"dev/items/weapons/thrown-weapons"},{"type":"link","label":"Projectile Weapons*","href":"/RogueLibs/docs/dev/items/weapons/projectile-weapons","docId":"dev/items/weapons/projectile-weapons"},{"type":"link","label":"Custom Projectiles*","href":"/RogueLibs/docs/dev/items/weapons/custom-projectiles","docId":"dev/items/weapons/custom-projectiles"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Inventory Checks","href":"/RogueLibs/docs/dev/items/inventory-checks","docId":"dev/items/inventory-checks"},{"type":"category","label":"Custom Abilities","items":[{"type":"link","label":"Creating a Custom Ability","href":"/RogueLibs/docs/dev/items/abilities/create-ability","docId":"dev/items/abilities/create-ability"},{"type":"link","label":"Rechargeable Abilities","href":"/RogueLibs/docs/dev/items/abilities/rechargeable-abilities","docId":"dev/items/abilities/rechargeable-abilities"},{"type":"link","label":"Chargeable Abilities","href":"/RogueLibs/docs/dev/items/abilities/chargeable-abilities","docId":"dev/items/abilities/chargeable-abilities"},{"type":"link","label":"Targetable Abilities","href":"/RogueLibs/docs/dev/items/abilities/targetable-abilities","docId":"dev/items/abilities/targetable-abilities"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Custom Traits and Effects","items":[{"type":"link","label":"Creating a Custom Trait","href":"/RogueLibs/docs/dev/traits/create-trait","docId":"dev/traits/create-trait"},{"type":"link","label":"Creating a Custom Effect","href":"/RogueLibs/docs/dev/traits/create-effect","docId":"dev/traits/create-effect"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Custom Interactions","items":[{"type":"link","label":"Creating a Custom Interaction","href":"/RogueLibs/docs/dev/interactions/create-interaction","docId":"dev/interactions/create-interaction"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Custom Disasters","items":[{"type":"link","label":"Creating a Custom Disaster","href":"/RogueLibs/docs/dev/disasters/create-disaster","docId":"dev/disasters/create-disaster"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Custom Unlocks","items":[{"type":"link","label":"Custom Unlocks","href":"/RogueLibs/docs/dev/unlocks/custom-unlocks","docId":"dev/unlocks/custom-unlocks"},{"type":"link","label":"Configuring Unlocks","href":"/RogueLibs/docs/dev/unlocks/configuring-unlocks","docId":"dev/unlocks/configuring-unlocks"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Custom Names","items":[{"type":"link","label":"Custom Names","href":"/RogueLibs/docs/dev/names/custom-names","docId":"dev/names/custom-names"},{"type":"link","label":"Custom Languages*","href":"/RogueLibs/docs/dev/names/custom-languages","docId":"dev/names/custom-languages"},{"type":"link","label":"Custom Name Providers","href":"/RogueLibs/docs/dev/names/name-providers","docId":"dev/names/name-providers"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Custom Sprites and Resources","href":"/RogueLibs/docs/dev/custom-sprites","docId":"dev/custom-sprites"},{"type":"link","label":"Extra Stuff","href":"/RogueLibs/docs/dev/extra","docId":"dev/extra"},{"type":"link","label":"Patching Utilities","href":"/RogueLibs/docs/dev/patching-utilities","docId":"dev/patching-utilities"},{"type":"category","label":"Hooks","items":[{"type":"link","label":"Hooks","href":"/RogueLibs/docs/dev/hooks/","docId":"dev/hooks/hooks"},{"type":"link","label":"Hook Factories","href":"/RogueLibs/docs/dev/hooks/hook-factories","docId":"dev/hooks/hook-factories"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Site Stuff","items":[{"type":"link","label":"Introduction","href":"/RogueLibs/docs/site/intro","docId":"site/intro"},{"type":"link","label":"Components Index","href":"/RogueLibs/docs/site/","docId":"site/index"},{"type":"category","label":"Components","items":[{"type":"link","label":"InventorySlot","href":"/RogueLibs/docs/site/components/InventorySlot","docId":"site/components/InventorySlot"},{"type":"link","label":"InventoryRow","href":"/RogueLibs/docs/site/components/InventoryRow","docId":"site/components/InventoryRow"},{"type":"link","label":"InventoryGrid","href":"/RogueLibs/docs/site/components/InventoryGrid","docId":"site/components/InventoryGrid"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Hooks","items":[{"type":"link","label":"useSelector","href":"/RogueLibs/docs/site/hooks/useSelector","docId":"site/hooks/useSelector"},{"type":"link","label":"useStorage","href":"/RogueLibs/docs/site/hooks/useStorage","docId":"site/hooks/useStorage"},{"type":"link","label":"useStorageArray","href":"/RogueLibs/docs/site/hooks/useStorageArray","docId":"site/hooks/useStorageArray"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true}]},"docs":{"dev/custom-sprites":{"id":"dev/custom-sprites","title":"Custom Sprites and Resources","description":"Adding image resources to a plugin is a bit tricky. Visual Studio loads any image resources as bitmaps, but we don\'t want that. You\'ll need to modify the resources manifest yourself, and add your images as binary files (or byte arrays). RogueLibs supports cropping and resizing your sprites, so, technically, you could even upload a spritesheet, and cut sprites out of it, but the performance gain would not be worth it (loading all of the 1204 64x64 sprites from Sidi\'s spritepack takes about 350 milliseconds, while patching methods is significantly slower - RogueLibs takes about 5 seconds to load).","sidebar":"documentationSidebar"},"dev/disasters/create-disaster":{"id":"dev/disasters/create-disaster","title":"Creating a Custom Disaster","description":"You can create your own custom disasters using a CustomDisaster class, provided by RogueLibs. You can configure the disaster\'s name, description and both of the messages that are displayed at the beginning of the floor. And, of course, you can determine the conditions that the disaster can (or must) happen under, and what happens at the start of and during this disaster. Additionally, you can quickly and easily create a removal mutator that removes your disaster from the pool.","sidebar":"documentationSidebar"},"dev/extra":{"id":"dev/extra","title":"Extra Stuff","description":"RogueLibs provides a couple of extra interfaces that you can use for any supported custom content hooks: IDoUpdate, IDoFixedUpdate. These interfaces correspond to the Update and FixedUpdate Unity methods (not directly, but through the game\'s Updater class).","sidebar":"documentationSidebar"},"dev/getting-started":{"id":"dev/getting-started","title":"Getting Started","description":"Welcome to the SoR mod-making guide featuring RogueLibs! Library and tools provided by RogueLibs really simplify the modding process, but you\'ll still need some basic C# knowledge to get started. If you have any questions, feel free to ask them in the official Discord\'s #\ud83d\udd27|modding channel.","sidebar":"documentationSidebar"},"dev/hooks/hook-factories":{"id":"dev/hooks/hook-factories","title":"Hook Factories","description":"Hook factories are responsible for the creation of hooks. Custom content classes use hook factories internally, so there\'s basically no need for you to create your own. But, if you want to semi-automate the creation of a lot of different items/traits with slightly differing functionality, you can create a class, that will handle everything, and turn its parts on/off conditionally after initializing the hook.","sidebar":"documentationSidebar"},"dev/hooks/hooks":{"id":"dev/hooks/hooks","title":"Hooks","description":"A hook is an object that is attached to another object (\\"hook\\" is a really vague word, jsyk). In RogueLibs hook types derive from IHook and IHook, and RogueLibs provides a mechanism to attach these hooks to vanilla types, such as InvItem, PlayfieldObject, Unlock, Trait and etc. Most custom content classes are based on hooks in one way or another.","sidebar":"documentationSidebar"},"dev/interactions/create-interaction":{"id":"dev/interactions/create-interaction","title":"Creating a Custom Interaction","description":"RogueLibs v3.5.0 introduced custom interactions with a pretty unique syntax. All of the code is condensed and basically can be put into a single method. You just need to keep in mind that the main function must be pure (mustn\'t do anything, except add/remove buttons and set callbacks), and that all of the side effects must be set using SetSideEffect or SetStopCallback.","sidebar":"documentationSidebar"},"dev/items/abilities/chargeable-abilities":{"id":"dev/items/abilities/chargeable-abilities","title":"Chargeable Abilities","description":"Custom abilities can be made chargeable by implementing the IAbilityChargeable interface. Ability\'s Count here works as the amount of stored up energy/charges. This interface makes use of some of the game\'s charging mechanics, but it doesn\'t completely rely on it. I\'d recommend taking a look at Recharging Items, if you need finer control.","sidebar":"documentationSidebar"},"dev/items/abilities/create-ability":{"id":"dev/items/abilities/create-ability","title":"Creating a Custom Ability","description":"Special abilities in SoR are actually implemented as items. They have SetupDetails, Count, and exist in the owner\'s inventory, just like items. The CustomAbility class provided by RogueLibs inherits from the CustomItem class and provides a default implementation of SetupDetails. Just like with custom items, you can use interfaces to expand your ability\'s functionality: IAbilityRechargeable, IAbilityChargeable, IAbilityTargetable.","sidebar":"documentationSidebar"},"dev/items/abilities/rechargeable-abilities":{"id":"dev/items/abilities/rechargeable-abilities","title":"Rechargeable Abilities","description":"Custom abilities can be made rechargeable by implementing the IAbilityRechargeable interface. Ability\'s Count here works as a cooldown and usually represents the amount of time to wait until full recharge. This interface makes use of some of the game\'s recharging mechanics, but it doesn\'t completely rely on it. I\'d recommend taking a look at Recharging Items, if you need finer control.","sidebar":"documentationSidebar"},"dev/items/abilities/targetable-abilities":{"id":"dev/items/abilities/targetable-abilities","title":"Targetable Abilities","description":"Custom abilities can be made targetable by implementing the IAbilityTargetable interface. You can determine the target of the special ability (for example, the closest agent), and a special ability indicator will be displayed over it. Then you\'ll be able to access the determined target through the CurrentTarget property.","sidebar":"documentationSidebar"},"dev/items/combinable-items":{"id":"dev/items/combinable-items","title":"Combinable Items","description":"Custom items can be made combinable with other items by implementing the IItemCombinable interface. You can define what kind of items your item is combinable with, what happens when you combine these items, and what tooltips to display in the combinable item\'s cell, and when hovering over it.","sidebar":"documentationSidebar"},"dev/items/create-item":{"id":"dev/items/create-item","title":"Creating a Custom Item","description":"RogueLibs provides classes and methods to create: usable, combinable, targetable (and targetable+) items. All custom items derive from the CustomItem class, which provides all of the basic item functionality. You can derive your custom item\'s class from specialized interfaces to expand its functionality (IItemUsable, IItemCombinable, IItemTargetable, IItemTargetableAnywhere). Custom items are initialized and integrated into the game using the RogueLibs.CreateCustomItem() method.","sidebar":"documentationSidebar"},"dev/items/inventory-checks":{"id":"dev/items/inventory-checks","title":"Inventory Checks","description":"Custom usable items might have varying restrictions, and it will be hard to enforce a consistent standard for that kind of stuff. That\'s why RogueLibs introduces special inventory checks, that will run before and after any usable/combinable/targetable items in the game. You can use these checks to prevent the item\'s intended function, or maybe somehow augment it.","sidebar":"documentationSidebar"},"dev/items/recharging-items":{"id":"dev/items/recharging-items","title":"Recharging Items","description":"RogueLibs doesn\'t provide any explicit functionality for rechargeable items, but you can easily implement that yourself, using the IDoUpdate interface. You\'ll find some useful code snippets below, that you can reuse for your own items.","sidebar":"documentationSidebar"},"dev/items/targetable-items":{"id":"dev/items/targetable-items","title":"Targetable Items","description":"Custom items can be made targetable by implementing the IItemTargetable interface. You can define what kind of objects, agents, items on the ground, projectiles or whatever, your item is compatible with, what happens when you use the item on that thing, and what text to display under the mouse cursor when hovering over something.","sidebar":"documentationSidebar"},"dev/items/targetable-items-plus":{"id":"dev/items/targetable-items-plus","title":"Targetable Items +","description":"Custom items can be made targetable+ (targetable anywhere) by implementing the IItemTargetableAnywhere. Normal targetable items can only be used on something actually present in the game, but as that parenthesised text implies, targetable+ items can be used anywhere on the screen. And so, this interface uses in-game positions instead of objects.","sidebar":"documentationSidebar"},"dev/items/usable-items":{"id":"dev/items/usable-items","title":"Usable Items","description":"Custom items can be made usable by implementing the IItemUsable interface, that defines a single method, UseItem. Usable items can be used by right-clicking them in the inventory, or using them from the toolbar (1-5 keys).","sidebar":"documentationSidebar"},"dev/items/weapons/custom-projectiles":{"id":"dev/items/weapons/custom-projectiles","title":"Custom Projectiles*","description":"","sidebar":"documentationSidebar"},"dev/items/weapons/melee-weapons":{"id":"dev/items/weapons/melee-weapons","title":"Melee Weapons*","description":"Melee weapons are realy complicated. But, thankfully, RogueLibs takes care of the most difficult part \u2014 patching. So, all you have to do is to create a class deriving from CustomWeaponMelee. I\'ve spent hundreds of hours patching the melee weapons code, and managed to condense all of it into a single class. It\'s ridiculous how overcomplicated and wet Matt\'s code is.","sidebar":"documentationSidebar"},"dev/items/weapons/projectile-weapons":{"id":"dev/items/weapons/projectile-weapons","title":"Projectile Weapons*","description":"","sidebar":"documentationSidebar"},"dev/items/weapons/thrown-weapons":{"id":"dev/items/weapons/thrown-weapons","title":"Thrown Weapons*","description":"","sidebar":"documentationSidebar"},"dev/names/custom-languages":{"id":"dev/names/custom-languages","title":"Custom Languages*","description":"You can add your custom languages to the game using the LanguageService.RegisterLanguageCode method.","sidebar":"documentationSidebar"},"dev/names/custom-names":{"id":"dev/names/custom-names","title":"Custom Names","description":"Custom localization in RogueLibs is implemented using instances of the CustomName class, which contain all languages\' translations at the same time (which isn\'t really efficient, but whatever). You can integrate your custom names into the game using the RogueLibs.CreateCustomName(...) method.","sidebar":"documentationSidebar"},"dev/names/name-providers":{"id":"dev/names/name-providers","title":"Custom Name Providers","description":"If you have some kind of a complicated localization logic, then you might want to create your own INameProvider. This way you can control what strings are returned by NameDB.GetName in a more generic way. You can even hook up your localization provider, if you don\'t like the localization system provided by RogueLibs.","sidebar":"documentationSidebar"},"dev/patching-utilities":{"id":"dev/patching-utilities","title":"Patching Utilities","description":"RogueLibs provides several utilities to help you with patching. Whether you use Harmony\'s attributes, Harmony instances directly, RogueLibs\' stuff or something else, is your choice. All of them have their own pros and cons. You can learn more about Harmony here.","sidebar":"documentationSidebar"},"dev/traits/create-effect":{"id":"dev/traits/create-effect","title":"Creating a Custom Effect","description":"RogueLibs provides classes and methods to create custom effects, and an interface to make status effects updateable. Just like items and traits, custom effects derive from a hook class, CustomEffect. If you want the effect to have some kind of a passive effect, then you might need to patch that in yourself.","sidebar":"documentationSidebar"},"dev/traits/create-trait":{"id":"dev/traits/create-trait","title":"Creating a Custom Trait","description":"RogueLibs provides classes and methods to create custom traits, and an interface to make traits updateable. Just like items, custom traits derive from a hook class, CustomTrait, and their functionality can be expanded with interfaces: ITraitUpdateable, just one in this case. If you want the trait to have some kind of a passive effect, then you might need to patch that in yourself.","sidebar":"documentationSidebar"},"dev/unlocks/configuring-unlocks":{"id":"dev/unlocks/configuring-unlocks","title":"Configuring Unlocks","description":"Custom unlocks\' displayed names, descriptions, images, buttons and their order in the list can be configured. You can even determine your own unlock conditions, change the displayed text and sprites conditionally and stuff like that.","sidebar":"documentationSidebar"},"dev/unlocks/custom-unlocks":{"id":"dev/unlocks/custom-unlocks","title":"Custom Unlocks","description":"Custom unlocks allow your custom content to be accessed through vanilla menus. Unlike other hooks, unlocks persist throughout the game, and get destroyed and created only when initially loading the game or changing save slots. RogueLibs also creates wrappers around vanilla unlocks, to ensure the compatibility of your unlocks with the vanilla ones.","sidebar":"documentationSidebar"},"intro":{"id":"intro","title":"Introduction","description":"Why should you use RogueLibs? Because it\'s really easy to use! Also, the game is really messy and it\'s an absolute hell to patch in even a single item! In case of items or traits, everything RogueLibs is asking of you is a class implementing a couple of interfaces. And, there are no alternatives... You\'ve got no choice. \ud83d\ude08","sidebar":"documentationSidebar"},"site/components/InventoryGrid":{"id":"site/components/InventoryGrid","title":"InventoryGrid","description":"Props","sidebar":"documentationSidebar"},"site/components/InventoryRow":{"id":"site/components/InventoryRow","title":"InventoryRow","description":"Props","sidebar":"documentationSidebar"},"site/components/InventorySlot":{"id":"site/components/InventorySlot","title":"InventorySlot","description":"Props","sidebar":"documentationSidebar"},"site/hooks/useSelector":{"id":"site/hooks/useSelector","title":"useSelector","description":"useSelector hook is useful, when you need to add/remove/toggle certain values.","sidebar":"documentationSidebar"},"site/hooks/useStorage":{"id":"site/hooks/useStorage","title":"useStorage","description":"useStorage is used to store strings in the browser\'s local storage.","sidebar":"documentationSidebar"},"site/hooks/useStorageArray":{"id":"site/hooks/useStorageArray","title":"useStorageArray","description":"useStorageArray is used to store strings in the browser\'s local storage.","sidebar":"documentationSidebar"},"site/index":{"id":"site/index","title":"Components Index","description":"Want to add some cool SoR-styled components to your site?","sidebar":"documentationSidebar"},"site/intro":{"id":"site/intro","title":"Introduction","description":"So, you want to create a cool-looking website for your mod/plugin?","sidebar":"documentationSidebar"},"user/installation":{"id":"user/installation","title":"Installation","description":"To start using mods, first you need to install BepInEx, the modding framework that we\'re using to mod Streets of Rogue. Then, install RogueLibs (both plugin and patcher - two different important files) and then any mods that you want to play with. You can find a lot of mods on SoR ModHub or GameBanana.","sidebar":"documentationSidebar"},"user/troubleshooting":{"id":"user/troubleshooting","title":"Frequently Encountered Problems","description":"Frequently encountered problems that get encountered way too frequently. No, Linux is not compatible with Windows. No, you can\'t just install half of the program and get it to work. And no, the gnomes in your computer box can\'t magically install everything for you (not yet). Just read the instructions.","sidebar":"documentationSidebar"}}}')}}]);