"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8227],{4214:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294),r=a(614);function o(e){let{children:t,language:a}=e;return n.createElement(r.Z,{className:"language-"+(a||"csharp")},t.replace(/\t/g,"    "))}},1016:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7462),r=a(7294);function o(e){let{children:t,...a}=e;return r.createElement("div",(0,n.Z)({role:"tabpanel"},a),t)}},5878:(e,t,a)=>{a.d(t,{Z:()=>f});var n=a(7294),r=a(6550),o=a(1980),l=a(7392),i=a(12);function u(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function s(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??u(a);return function(e){const t=(0,l.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function c(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function d(e){let{queryString:t=!1,groupId:a}=e;const l=(0,r.k6)(),i=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,o._X)(i),(0,n.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(l.location.search);t.set(i,e),l.replace({...l.location,search:t.toString()})}),[i,l])]}function p(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,o=s(e),[l,u]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:o}))),[p,m]=d({queryString:a,groupId:r}),[h,g]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,i.Nk)(a);return[r,(0,n.useCallback)((e=>{a&&o.set(e)}),[a,o])]}({groupId:r}),f=(()=>{const e=p??h;return c({value:e,tabValues:o})?e:null})();(0,n.useLayoutEffect)((()=>{f&&u(f)}),[f]);return{selectedValue:l,selectValue:(0,n.useCallback)((e=>{if(!c({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);u(e),m(e),g(e)}),[m,g,o]),tabValues:o}}var m=a(6010);const h={tabItem:"tabItem_V91s",tabItemActive:"tabItemActive_JsUu",blink:"blink_ZPVS",tab:"tab_ntnM"};const g={left:37,right:39};function f(e){const{lazy:t,defaultValue:a,values:r,groupId:o}=e,l=n.Children.toArray(e.children),{tabValues:i,selectedValue:u,selectValue:s}=p({children:l,defaultValue:a,values:r,groupId:o}),c=[],d=e=>{const t=e.currentTarget,a=r[c.indexOf(t)].value;s(a),null!=o&&setTimeout((()=>{(function(e){const{top:t,left:a,bottom:n,right:r}=e.getBoundingClientRect(),{innerHeight:o,innerWidth:l}=window;return t>=0&&r<=l&&n<=o&&a>=0})(t)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(h.tabItemActive),setTimeout((()=>t.classList.remove(h.tabItemActive)),2e3))}),150)},f=e=>{let t;switch(e.keyCode){case g.right:{const a=c.indexOf(e.target)+1;t=c[a]||c[0];break}case g.left:{const a=c.indexOf(e.target)-1;t=c[a]||c[c.length-1];break}default:return}t.focus()},b=(e,t)=>t.value===e||t.values&&-1!=t.values.indexOf(e);return n.createElement("div",{className:"tabs-container"},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:"tabs"},r.map((e=>{let{value:t,label:a}=e;return n.createElement("li",{role:"tab",tabIndex:u===t?0:-1,"aria-selected":u===t,className:(0,m.Z)("tabs__item",h.tabItem,{"tabs__item--active":u===t}),key:t,ref:e=>e&&c.push(e),onKeyDown:f,onFocus:d,onClick:d},a)}))),t?n.cloneElement(l.find((e=>b(u,e.props))),{className:h.tab}):n.createElement("div",null,l.map(((e,t)=>n.cloneElement(e,{key:t,hidden:!b(u,e.props),className:h.tab})))),n.createElement("br",null))}},159:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>f,frontMatter:()=>s,metadata:()=>d,toc:()=>m});var n=a(7462),r=(a(7294),a(3905)),o=a(5878),l=a(1016),i=(a(4996),a(4214));const u='using UnityEngine;\n\nnamespace RogueLibsCore.Test\n{\n    [ItemCategories(RogueCategories.Food, RogueCategories.Technology)]\n    public class QuantumFud : CustomItem, IItemUsable, IDoUpdate\n    {\n        [RLSetup]\n        public static void Setup()\n        {\n            RogueLibs.CreateCustomItem<QuantumFud>()\n                .WithName(new CustomNameInfo("Quantum Fud"))\n                .WithDescription(new CustomNameInfo("A very complicated piece of quantum technology. When you eat it, its quantum equivalent clone is consumed, while the original thing remains intact."))\n                .WithSprite(Properties.Resources.QuantumFud)\n                .WithUnlock(new ItemUnlock\n                {\n                    UnlockCost = 10,\n                    LoadoutCost = 15,\n                    CharacterCreationCost = 10,\n                   Prerequisites = { VanillaItems.FoodProcessor },\n                });\n        }\n\n        public override void SetupDetails()\n        {\n            Item.itemType = ItemTypes.Food;\n            Item.itemValue = 180;\n            Item.healthChange = 1;\n            Item.cantBeCloned = true;\n            Item.goesInToolbar = true;\n        }\n\n        public float Cooldown { get; set; }\n        public void Update() => Cooldown = Mathf.Max(Cooldown - Time.deltaTime, 0f);\n\n        public bool UseItem()\n        {\n            if (Cooldown != 0f) return false;\n\n            int heal = new ItemFunctions().DetermineHealthChange(Item, Owner);\n            Owner!.statusEffects.ChangeHealth(heal);\n\n            if (Owner.HasTrait(VanillaTraits.ShareTheHealth)\n                || Owner.HasTrait(VanillaTraits.ShareTheHealth2))\n                new ItemFunctions().GiveFollowersHealth(Owner, heal);\n\n            gc.audioHandler.Play(Owner, VanillaAudio.UseFood);\n            Cooldown = 0.5f;\n            return true;\n        }\n    }\n}\n',s={},c="Recharging Items",d={unversionedId:"dev/items/recharging-items",id:"dev/items/recharging-items",title:"Recharging Items",description:"RogueLibs doesn't provide any explicit functionality for rechargeable items, but you can easily implement that yourself, using the IDoUpdate interface. You'll find some useful code snippets below, that you can reuse for your own items.",source:"@site/docs/dev/items/recharging-items.mdx",sourceDirName:"dev/items",slug:"/dev/items/recharging-items",permalink:"/RogueLibs/docs/dev/items/recharging-items",draft:!1,editUrl:"https://github.com/SugarBarrel/RogueLibs/edit/main/website/docs/dev/items/recharging-items.mdx",tags:[],version:"current",frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Targetable Items +",permalink:"/RogueLibs/docs/dev/items/targetable-items-plus"},next:{title:"Melee Weapons*",permalink:"/RogueLibs/docs/dev/items/weapons/melee-weapons"}},p={},m=[{value:"Making items rechargeable",id:"making-rechargeable",level:2},{value:"Presets",id:"presets",level:2},{value:"Examples",id:"examples",level:2}],h={toc:m},g="wrapper";function f(e){let{components:t,...a}=e;return(0,r.kt)(g,(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"recharging-items"},"Recharging Items"),(0,r.kt)("p",null,"RogueLibs doesn't provide any explicit functionality for rechargeable items, but you can easily implement that yourself, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"IDoUpdate")," interface. You'll find some useful code snippets below, that you can reuse for your own items."),(0,r.kt)("h2",{id:"making-rechargeable"},"Making items rechargeable"),(0,r.kt)("p",null,"Make your custom item's class implement the ",(0,r.kt)("a",{parentName:"p",href:"../extra#update-interfaces"},(0,r.kt)("inlineCode",{parentName:"a"},"IDoUpdate")," interface"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="MyRechargeableItem.cs"',title:'"MyRechargeableItem.cs"'},"// highlight-next-line\npublic class MyRechargeableItem : CustomItem, IDoUpdate\n{\n    /* ... */\n}\n")),(0,r.kt)("h2",{id:"presets"},"Presets"),(0,r.kt)(o.Z,{defaultValue:"cooldown",values:[{label:"Cooldown",value:"cooldown"},{label:"Charge",value:"charge"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"cooldown",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Cooldown")," represents the amount of seconds to wait until full recharge."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public float Cooldown { get; private set; }\n    public void Update() => Cooldown = Mathf.Max(Cooldown - Time.deltaTime, 0f);\n")),(0,r.kt)("p",null,"With adjustable recharging speed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public float RechargeSpeed = 1f;\n\n    public float Cooldown { get; private set; }\n    public void Update() => Cooldown = Mathf.Max(Cooldown - Time.deltaTime * RechargeSpeed, 0f);\n")),(0,r.kt)("p",null,"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public bool UseItem()\n    {\n        if (Cooldown != 0f) return false;\n        /* ... */\n        Cooldown = 1.5f;\n        return true;\n    }\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"You can use other activation methods too, like ",(0,r.kt)("inlineCode",{parentName:"p"},"CombineItems"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TargetObject"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TargetPosition")," and etc.")),(0,r.kt)("p",null,"If you want to display ",(0,r.kt)("inlineCode",{parentName:"p"},"Cooldown")," as the item's count, then override the ",(0,r.kt)("inlineCode",{parentName:"p"},"GetCountString")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public override CustomTooltip GetCountString()\n    {\n        if (Cooldown != 0f) return new CustomTooltip(Cooldown, Color.red);\n        return base.GetCountString(); // display default count\n    }\n"))),(0,r.kt)(l.Z,{value:"charge",mdxType:"TabItem"},(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Charge"),' represents the amount of seconds of "stored up energy".'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public float Charge { get; private set; } = 5f;\n    public void Update() => Charge = Mathf.Min(Charge + Time.deltaTime, 5f);\n")),(0,r.kt)("p",null,"With adjustable charging speed and maximum charge:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public float ChargeSpeed = 1f, MaxCharge = 5f;\n\n    public float Charge { get; private set; } = 5f;\n    public void Update() => Charge = Mathf.Min(Charge + Time.deltaTime * ChargeSpeed, MaxCharge);\n")),(0,r.kt)("p",null,"Plus, with a charging delay:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public float DelayThreshold = 3f, ChargeSpeed = 1f, MaxCharge = 5f;\n\n    private float lastUsage;\n    public float Charge { get; private set; } = 5f;\n    public void Update()\n    {\n        if (lastUsage + DelayThreshold < Time.time)\n            Charge = Mathf.Min(Charge + Time.deltaTime * ChargeSpeed, MaxCharge);\n    }\n")),(0,r.kt)("p",null,"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public bool UseItem()\n    {\n        if (Charge < 1.5f) return false;\n        /* ... */\n        Charge -= 1.5f;\n        lastUsage = Time.time;\n        return true;\n    }\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"You can use other activation methods too, like ",(0,r.kt)("inlineCode",{parentName:"p"},"CombineItems"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TargetObject"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TargetPosition")," and etc.")),(0,r.kt)("p",null,"If you want to display ",(0,r.kt)("inlineCode",{parentName:"p"},"Charge")," as the item's count, then override the ",(0,r.kt)("inlineCode",{parentName:"p"},"GetCountString")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    public override CustomTooltip GetCountString()\n    {\n        string text = $"{Charge} ({base.GetCountString()})"; // display both charge and count\n        Color color = Color.Lerp(Color.red, Color.white, Charge / MaxCharge);\n        // color between red and white: red - no charge, white - full charge\n        return new CustomTooltip(text, color);\n    }\n')))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"There's also a vanilla way of recharging items, but it's really messy and unreliable.")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)(o.Z,{defaultValue:"quantumfud",values:[{label:"Quantum Fud",value:"quantumfud"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"quantumfud",mdxType:"TabItem"},(0,r.kt)(i.Z,{mdxType:"CodeSnippet"},u))))}f.isMDXComponent=!0}}]);