# `useStorageArray`

`useStorageArray` is used to store strings in the browser's local storage.  
It also synchronizes all instances using the same storage slot.

:::info
It works just like [`useStorage`](./useStorage) but with string arrays instead of single strings.  
It joins the stored strings with a semicolon (`;`), like this: `value1;value2;value3`.
:::

## Signature {#signature}

```ts
function (
  slotName: string | null, // name of the storage slot to use
  defaultValues?: string[] | (() => string[] | undefined), // default values of the storage slot
  onChange?: (values: string[]) => void // change event handler
): [
    string[], // current values
    React.Dispatch<React.SetStateAction<string[]>> // function to set the values
  ]
```

## Usage {#usage}

:::info
If `slotName` is `null`, the hook works just like a `useState`.
:::

<Tabs defaultValue="ts"
  values={[
    {value:'ts', label:'TypeScript'},
    {value:'js', label:'JavaScript'},
  ]}>
<TabItem value="ts">

```ts
import useStorageArray from "../hooks/useStorageArray";

export default function ({/* your props */}: Props) {

  const [values, setValues] = useStorageArray("my.storage.slot", []);

  /* ... */
}
```

</TabItem>
<TabItem value="js">

```js
import useStorageArray from "../hooks/useStorageArray";

export default function ({/* your props */}) {

  const [values, setValues] = useStorageArray("my.storage.slot", []);

  /* ... */
}
```

</TabItem>
</Tabs>

:::caution
The values are read from the local storage in an `useEffect` hook, so, on the first render, the values will be the default ones.
:::
